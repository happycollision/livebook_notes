# Ticketing core

```elixir
# Copy pasta from Ash Livebook Tutorial
Application.put_env(:ash, :validate_api_resource_inclusion?, false)
Application.put_env(:ash, :validate_api_config_inclusion?, false)
Mix.install([:ash, :kino], consolidate_protocols: false)
```

## Core definitions in Ash

```elixir
defmodule BoxOffice.Core.Patron do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  actions(do: defaults([:create, :read, :update, :destroy]))

  attributes do
    uuid_primary_key(:id)
    attribute(:name, :string)
  end

  # Added the inverse relationship of belongs_to in the reservation.
  # This way we can reference :reservations inside the aggregates.
  relationships do
    has_many(:reservations, BoxOffice.Core.Reservation)
  end

  code_interface do
    define_for(BoxOffice.Core)

    define(:create, args: [:name])
  end

  # <- Add the aggregates here
  aggregates do
    count(:count_of_reservations, :reservations)
  end
end

defmodule BoxOffice.Core.Seat do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  actions(do: defaults([:create, :read, :update, :destroy]))

  attributes do
    uuid_primary_key(:id)
    attribute(:name, :string)
  end

  relationships do
    has_many(:reservations, BoxOffice.Core.Reservation)

    many_to_many :seating_charts, BoxOffice.Core.SeatingChart do
      through(BoxOffice.Core.SeatSeatingChart)
      source_attribute_on_join_resource(:seat_id)
      destination_attribute_on_join_resource(:seating_chart_id)
    end
  end

  code_interface do
    define_for(BoxOffice.Core)

    define(:create, args: [:name])
  end
end

defmodule BoxOffice.Core.SeatSeatingChart do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  relationships do
    belongs_to(:seat, BoxOffice.Core.Seat, primary_key?: true, allow_nil?: false)
    belongs_to(:seating_chart, BoxOffice.Core.SeatingChart, primary_key?: true, allow_nil?: false)
  end

  actions do
    defaults([:create, :read, :update, :destroy])
  end
end

defmodule BoxOffice.Core.SeatingChart do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  actions do
    defaults([:create, :read, :update, :destroy])

    update :add_seat do
      accept([])
      argument(:seat_id, :uuid, allow_nil?: false)
      change(manage_relationship(:seat_id, :seats, type: :append))
    end
  end

  attributes do
    uuid_primary_key(:id)
    attribute(:name, :string)
  end

  relationships do
    many_to_many :seats, BoxOffice.Core.Seat do
      through(BoxOffice.Core.SeatSeatingChart)
      source_attribute_on_join_resource(:seating_chart_id)
      destination_attribute_on_join_resource(:seat_id)
    end

    has_many(:performances, BoxOffice.Core.Performance)
  end

  code_interface do
    define_for(BoxOffice.Core)

    define(:create, args: [:name])
    define(:add_seat, args: [:seat_id])
  end

  aggregates do
    count(:count_of_seats, :seats)
  end
end

defmodule BoxOffice.Core.Production do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key(:id)
    attribute(:title, :string)

    create_timestamp(:created_at)
    update_timestamp(:updated_at)
  end

  actions(do: defaults([:create, :read, :update, :destroy]))

  relationships do
    has_many(:performances, BoxOffice.Core.Performance)
  end

  code_interface do
    define_for(BoxOffice.Core)

    define(:create, args: [:title])
  end
end

defmodule BoxOffice.Core.Performance do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key(:id)
    attribute(:datetime, :naive_datetime)

    create_timestamp(:created_at)
    update_timestamp(:updated_at)
  end

  actions(do: defaults([:create, :read, :update, :destroy]))

  relationships do
    belongs_to(:production, BoxOffice.Core.Production) do
      attribute_writable?(true)
    end

    belongs_to(:seating_chart, BoxOffice.Core.SeatingChart) do
      attribute_writable?(true)
    end

    has_many(:reservations, BoxOffice.Core.Reservation)
  end

  code_interface do
    define_for(BoxOffice.Core)

    define(:create, args: [:production_id, :datetime, :seating_chart_id])
  end

  aggregates do
    count(:count_of_reserved_seats, :reservations)
  end

  calculations do
    calculate(
      :count_of_unreserved_seats,
      :integer,
      expr(seating_chart.count_of_seats - count_of_reserved_seats)
    )
  end
end

defmodule BoxOffice.Core.Reservation do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  actions do
    defaults([:read, :update])

    # On creation set the patron by providing the id
    create(:make, do: accept([:patron_id, :performance_id, :seat_id]))
  end

  attributes do
    uuid_primary_key(:id)

    create_timestamp(:created_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to(:patron, BoxOffice.Core.Patron) do
      # Set to writable so you can directly set the patron_id inside the :open action
      attribute_writable?(true)
    end

    belongs_to(:seat, BoxOffice.Core.Seat) do
      attribute_writable?(true)
    end

    belongs_to(:performance, BoxOffice.Core.Performance) do
      attribute_writable?(true)
    end
  end

  code_interface do
    define_for(BoxOffice.Core)

    define(:make, args: [:patron_id, :performance_id, :seat_id])
  end
end

defmodule BoxOffice.Core do
  use Ash.Api

  resources do
    resource(BoxOffice.Core.Reservation)
    resource(BoxOffice.Core.Patron)
    resource(BoxOffice.Core.Production)
    resource(BoxOffice.Core.Performance)
    resource(BoxOffice.Core.Seat)
    resource(BoxOffice.Core.SeatingChart)
    resource(BoxOffice.Core.SeatSeatingChart)
  end
end
```

## Seed

```elixir
patron = BoxOffice.Core.Patron.create!("Sally")
seating_chart = BoxOffice.Core.SeatingChart.create!("main chart")

names =
  for alpha <- ?A..?G, numb <- 1..10 do
    to_string([alpha]) <> to_string(numb)
  end
  |> Enum.map(fn name -> %{name: name} end)

seats =
  BoxOffice.Core.bulk_create!(names, BoxOffice.Core.Seat, :create, return_records?: true) |> dbg

seats.records
|> Enum.map(fn seat ->
  BoxOffice.Core.SeatingChart.add_seat!(seating_chart, seat.id)
end)

production = BoxOffice.Core.Production.create!("A Funny Thing Happened on the Way to the Forum")

performance =
  BoxOffice.Core.Performance.create!(production.id, ~N[2024-01-01 20:00:00], seating_chart.id)

reservation = BoxOffice.Core.Reservation.make!(patron.id, performance.id, hd(seats.records).id)
```

## Query

```elixir
require Ash.Query

[reservation] =
  BoxOffice.Core.Reservation
  |> Ash.Query.sort(created_at: :desc)
  |> Ash.Query.limit(1)
  |> BoxOffice.Core.read!()
  |> BoxOffice.Core.load!([:patron, :seat, performance: [:seating_chart]])

reservation
```

```elixir
BoxOffice.Core.load!(reservation.performance, [
  :count_of_reserved_seats,
  :count_of_unreserved_seats
])
```

## Storage

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Ash.DataLayer.Ets.Kino do
  @moduledoc """
  A kino for interactively viewing Ash ETS data.

  ## Examples

      Ash.DataLayer.Ets.Kino.new(SomeResource)
  """

  @behaviour Kino.Table

  @type t :: Kino.Table.t()

  @doc """
  Creates a new kino displaying the given Ash ETS table.
  """
  @spec new(:ets.tid()) :: t()
  def new(tid) do
    case :ets.info(tid, :protection) do
      :private ->
        raise ArgumentError,
              "the given table must be either public or protected, but a private one was given"

      :undefined ->
        raise ArgumentError,
              "the given table identifier #{inspect(tid)} does not refer to an existing ETS table"

      _ ->
        :ok
    end

    Kino.Table.new(__MODULE__, {tid})
  end

  @impl true
  def init({tid}) do
    table_name = :ets.info(tid, :name)
    name = "Ash ETS #{inspect(table_name)}"
    info = %{name: name, features: [:refetch, :pagination]}
    {:ok, info, %{tid: tid}}
  end

  @impl true
  def get_data(rows_spec, state) do
    records =
      get_records(state.tid, rows_spec)
      |> Enum.map(fn {ids, data} -> Map.merge(data, ids) end)

    data =
      Enum.map(records, &Map.values/1)
      |> Enum.map(fn values ->
        Enum.map(values, fn
          value ->
            cond do
              is_binary(value) && !String.valid?(value) ->
                inspect(value)

              match?(%NaiveDateTime{}, value) ->
                to_string(value)

              match?(%DateTime{}, value) ->
                to_string(value)

              match?(%Date{}, value) ->
                to_string(value)

              match?(%Time{}, value) ->
                to_string(value)

              true ->
                value
            end
        end)
      end)

    columns =
      Enum.at(records, 0)
      |> Map.keys()
      |> Enum.map(fn label -> %{key: label, label: label} end)

    total_rows = :ets.info(state.tid, :size)
    {:ok, %{columns: columns, data: {:rows, data}, total_rows: total_rows}, state}
  end

  defp get_records(tid, rows_spec) do
    query = :ets.table(tid)
    cursor = :qlc.cursor(query)

    if rows_spec.offset > 0 do
      :qlc.next_answers(cursor, rows_spec.offset)
    end

    records = :qlc.next_answers(cursor, rows_spec.limit)
    :qlc.delete_cursor(cursor)
    records
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Ash.DataLayer.Ets.Kino.new(BoxOffice.Core.SeatingChart)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Ash.DataLayer.Ets.Kino.new(BoxOffice.Core.Seat)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Ash.DataLayer.Ets.Kino.new(BoxOffice.Core.SeatSeatingChart)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Ash.DataLayer.Ets.Kino.new(BoxOffice.Core.Patron)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Ash.DataLayer.Ets.Kino.new(BoxOffice.Core.Production)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Ash.DataLayer.Ets.Kino.new(BoxOffice.Core.Performance)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Ash.DataLayer.Ets.Kino.new(BoxOffice.Core.Reservation)
```
